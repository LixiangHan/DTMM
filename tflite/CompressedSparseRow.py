# automatically generated by the FlatBuffers compiler, do not modify

# namespace: tflite

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class CompressedSparseRow(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = CompressedSparseRow()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCompressedSparseRow(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    @classmethod
    def CompressedSparseRowBufferHasIdentifier(cls, buf, offset, size_prefixed=False):
        return flatbuffers.util.BufferHasIdentifier(buf, offset, b"\x54\x46\x4C\x33", size_prefixed=size_prefixed)

    # CompressedSparseRow
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # CompressedSparseRow
    def RowPtr(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int16Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 2))
        return 0

    # CompressedSparseRow
    def RowPtrAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int16Flags, o)
        return 0

    # CompressedSparseRow
    def RowPtrLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CompressedSparseRow
    def RowPtrIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        return o == 0

    # CompressedSparseRow
    def ColIdx(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Int16Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 2))
        return 0

    # CompressedSparseRow
    def ColIdxAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Int16Flags, o)
        return 0

    # CompressedSparseRow
    def ColIdxLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # CompressedSparseRow
    def ColIdxIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # CompressedSparseRow
    def InputCh(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint16Flags, o + self._tab.Pos)
        return 0

def CompressedSparseRowStart(builder): builder.StartObject(3)
def Start(builder):
    return CompressedSparseRowStart(builder)
def CompressedSparseRowAddRowPtr(builder, rowPtr): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(rowPtr), 0)
def AddRowPtr(builder, rowPtr):
    return CompressedSparseRowAddRowPtr(builder, rowPtr)
def CompressedSparseRowStartRowPtrVector(builder, numElems): return builder.StartVector(2, numElems, 2)
def StartRowPtrVector(builder, numElems):
    return CompressedSparseRowStartRowPtrVector(builder, numElems)
def CompressedSparseRowAddColIdx(builder, colIdx): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(colIdx), 0)
def AddColIdx(builder, colIdx):
    return CompressedSparseRowAddColIdx(builder, colIdx)
def CompressedSparseRowStartColIdxVector(builder, numElems): return builder.StartVector(2, numElems, 2)
def StartColIdxVector(builder, numElems):
    return CompressedSparseRowStartColIdxVector(builder, numElems)
def CompressedSparseRowAddInputCh(builder, inputCh): builder.PrependUint16Slot(2, inputCh, 0)
def AddInputCh(builder, inputCh):
    return CompressedSparseRowAddInputCh(builder, inputCh)
def CompressedSparseRowEnd(builder): return builder.EndObject()
def End(builder):
    return CompressedSparseRowEnd(builder)
try:
    from typing import List
except:
    pass

class CompressedSparseRowT(object):

    # CompressedSparseRowT
    def __init__(self):
        self.rowPtr = None  # type: List[int]
        self.colIdx = None  # type: List[int]
        self.inputCh = 0  # type: int

    @classmethod
    def InitFromBuf(cls, buf, pos):
        compressedSparseRow = CompressedSparseRow()
        compressedSparseRow.Init(buf, pos)
        return cls.InitFromObj(compressedSparseRow)

    @classmethod
    def InitFromObj(cls, compressedSparseRow):
        x = CompressedSparseRowT()
        x._UnPack(compressedSparseRow)
        return x

    # CompressedSparseRowT
    def _UnPack(self, compressedSparseRow):
        if compressedSparseRow is None:
            return
        if not compressedSparseRow.RowPtrIsNone():
            if np is None:
                self.rowPtr = []
                for i in range(compressedSparseRow.RowPtrLength()):
                    self.rowPtr.append(compressedSparseRow.RowPtr(i))
            else:
                self.rowPtr = compressedSparseRow.RowPtrAsNumpy()
        if not compressedSparseRow.ColIdxIsNone():
            if np is None:
                self.colIdx = []
                for i in range(compressedSparseRow.ColIdxLength()):
                    self.colIdx.append(compressedSparseRow.ColIdx(i))
            else:
                self.colIdx = compressedSparseRow.ColIdxAsNumpy()
        self.inputCh = compressedSparseRow.InputCh()

    # CompressedSparseRowT
    def Pack(self, builder):
        if self.rowPtr is not None:
            if np is not None and type(self.rowPtr) is np.ndarray:
                rowPtr = builder.CreateNumpyVector(self.rowPtr)
            else:
                CompressedSparseRowStartRowPtrVector(builder, len(self.rowPtr))
                for i in reversed(range(len(self.rowPtr))):
                    builder.PrependInt16(self.rowPtr[i])
                rowPtr = builder.EndVector()
        if self.colIdx is not None:
            if np is not None and type(self.colIdx) is np.ndarray:
                colIdx = builder.CreateNumpyVector(self.colIdx)
            else:
                CompressedSparseRowStartColIdxVector(builder, len(self.colIdx))
                for i in reversed(range(len(self.colIdx))):
                    builder.PrependInt16(self.colIdx[i])
                colIdx = builder.EndVector()
        CompressedSparseRowStart(builder)
        if self.rowPtr is not None:
            CompressedSparseRowAddRowPtr(builder, rowPtr)
        if self.colIdx is not None:
            CompressedSparseRowAddColIdx(builder, colIdx)
        CompressedSparseRowAddInputCh(builder, self.inputCh)
        compressedSparseRow = CompressedSparseRowEnd(builder)
        return compressedSparseRow
